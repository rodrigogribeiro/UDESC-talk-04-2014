\begin{code}
module Code where
\end{code}

definition of natural numbers: Peano Style.

%<*nat>
\begin{code}
data ℕ : Set where
   zero  : ℕ
   suc   : (n : ℕ) → ℕ    
\end{code}
%</nat>

Some pragmas to tell Agda to use decimal numbers to represent ℕ values.

\begin{code}
{-# BUILTIN NATURAL ℕ #-}
{-# BUILTIN ZERO zero #-}
{-# BUILTIN SUC suc #-}
\end{code}

Addition of natural numbers

%<*plus>
\begin{code}
_+_ : ℕ → ℕ → ℕ
zero   + n = n
suc m  + n = suc (m + n)
\end{code}
%</plus>

Definition of lists.

%<*listdef>
\begin{code}
data List (A : Set) : Set where
  []  : List A
  _∷_ : A → List A → List A 
\end{code}
%</listdef>

Example function over lists: length

\begin{code}
length : {A : Set} → List A → ℕ
length []       = 0
length (x ∷ xs) = suc (length xs)
\end{code}

Maybe data type.

%<*maybe>
\begin{code}
data Maybe (A : Set) : Set where
  nothing : Maybe A
  just    : A → Maybe A
\end{code}
%</maybe>

Sample lookup without a strong spec.

%<*lookupweak>
\begin{code}
lookupWeak : {A : Set} → ℕ → List A → Maybe A
lookupWeak n       []       = nothing
lookupWeak 0       (x ∷ _)  = just x
lookupWeak (suc n) (_ ∷ xs) = lookupWeak n xs
\end{code}
%</lookupweak>

Boring code for infix operators.

\begin{code}
infix 4 _∈_
infixr 4 _∷_
\end{code}

List membership predicate.

%<*indef>
\begin{code}
data _∈_ {A : Set} : A → List A → Set where
  here  : ∀ {x xs} → x ∈ x ∷ xs
  there : ∀ {x y xs} → y ∈ xs → y ∈ (x ∷ xs)
\end{code}
%</indef>

Function to recover an index from a list membership proof.

%<*index>
\begin{code}
index : ∀ {A : Set}{x : A}{xs : List A} → x ∈ xs → ℕ
index here      = zero
index (there n) = suc (index n)
\end{code}
%</index>

Specification of a lookup algorithm as a data type.

%<*lookupData>
\begin{code}
data Lookup {A}(xs : List A) : ℕ → Set where
  inside  : ∀ x (p : x ∈ xs) → Lookup xs (index p)
  outside : ∀ m → Lookup xs (length xs + m)  
\end{code}
%</lookupData>

Correct by construction list lookup function.

%<*lookupCorrect>
\begin{code}
lookup : {A : Set}(xs : List A)(n : ℕ) → Lookup xs n
lookup [] n = outside n
lookup (x ∷ xs) zero = inside x here
lookup (x ∷ xs) (suc n) with lookup xs n 
lookup (x ∷ xs) (suc .(index p))       | inside y p = inside y (there p)
lookup (x ∷ xs) (suc .(length xs + m)) | outside m = outside m
\end{code}
%</lookupCorrect>

type checking lambda terms
---------------------------

Type syntax and contexts

%<*basedefs>
\begin{code}
data Ty : Set where
  ι   : Ty
  _⇒_ : Ty → Ty → Ty

Ctx : Set
Ctx = List Ty
\end{code}
%</basedefs>

Expression syntax

%<*rawterms>
\begin{code}
data Exp : Set where
  val : Exp
  var : ℕ → Exp
  abs : Ty → Exp → Exp
  app : Exp → Exp → Exp
\end{code}
%</rawterms>

Type derivations

\begin{code}
infix 4 _⊢_

infixl 4 _,_

_,_ : {A : Set} → List A → A → List A
Γ , x = x ∷ Γ
\end{code}

%<*derivation>
\begin{code}
data _⊢_ (Γ : Ctx) : Ty → Set where
  tval : Γ ⊢ ι
  tvar : ∀ {t} (p : t ∈ Γ) → Γ ⊢ t
  tabs : ∀ t {t'} → Γ , t ⊢ t' → Γ ⊢ t ⇒ t' 
  tapp : ∀ {t t'} → Γ ⊢ (t ⇒ t') → 
                    Γ ⊢ t → 
                    Γ ⊢ t'
\end{code}
%</derivation>

erasure of type derivations

%<*erase>
\begin{code}
erase : ∀ {Γ t} → Γ ⊢ t → Exp
erase tval = val
erase (tvar p) = var (index p)
erase (tabs t p) = abs t (erase p)
erase (tapp p p') = app (erase p) (erase p')
\end{code}
%</erase>

Type checker definitions
------------------------

%<*infer>
\begin{code}
data Infer (Γ : Ctx) : Exp → Set where
  ok : ∀ {t}(d : Γ ⊢ t) → Infer Γ (erase d)
  bad : ∀ {e} → Infer Γ e
\end{code}
%</infer>

%<*typecmp>
\begin{code}
data TyEq : Ty → Ty → Set where
  eq  : ∀ {t} → TyEq t t
  neq : ∀ {t t'} → TyEq t t'

_≟_ : (t t' : Ty) → TyEq t t'
ι ≟ ι = eq
ι ≟ (t' ⇒ t'') = neq
(t ⇒ t₁) ≟ ι = neq
(t ⇒ t₁) ≟ (t' ⇒ t'') with t ≟ t' | t₁ ≟ t'' 
(.t' ⇒ .t'') ≟ (t' ⇒ t'') | eq | eq = eq
(t ⇒ t₁) ≟ (t' ⇒ t'') | _ | _ = neq
\end{code}
%</typecmp>


%<*typechecker1>
\begin{code}
tc : ∀ Γ (e : Exp) → Infer Γ e
tc Γ val = ok tval
tc Γ (var x) with lookup Γ x 
tc Γ (var .(index p)) | inside x p = ok (tvar p)
tc Γ (var .(length Γ + m)) | outside m = bad
tc Γ (abs t e) with tc (Γ , t) e 
tc Γ (abs t .(erase d)) | ok d = ok (tabs t d)
tc Γ (abs t e) | bad = bad
tc Γ (app e e') with tc Γ e | tc Γ e' 
tc Γ (app .(erase d) .(erase d₁)) | ok {t ⇒ _} d | ok {t'} d₁ with t ≟ t' 
tc Γ (app .(erase d) .(erase d₁)) | ok {t ⇒ z} d | ok d₁ | eq = ok (tapp d d₁)
tc Γ (app .(erase d) .(erase d₁)) | ok {t ⇒ z} d | ok d₁ | neq = bad
tc Γ (app e e') | _ | _ = bad
\end{code}
%</typechecker1>
